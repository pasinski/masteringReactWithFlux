/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDebugTool
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var performanceNow = require('fbjs/lib/performanceNow');
var warning = require('fbjs/lib/warning');

var eventHandlers = [];
var handlerDoesThrowForEvent = {};

function emitEvent(handlerFunctionName, arg1, arg2, arg3, arg4, arg5) {
  if (process.env.NODE_ENV !== 'production') {
    eventHandlers.forEach(function (handler) {
      try {
        if (handler[handlerFunctionName]) {
          handler[handlerFunctionName](arg1, arg2, arg3, arg4, arg5);}} 

      catch (e) {
        process.env.NODE_ENV !== 'production' ? warning(!handlerDoesThrowForEvent[handlerFunctionName], 'exception thrown by devtool while handling %s: %s', handlerFunctionName, e.message) : void 0;
        handlerDoesThrowForEvent[handlerFunctionName] = true;}});}}





var isProfiling = false;
var flushHistory = [];
var currentFlushNesting = 0;
var currentFlushMeasurements = null;
var currentFlushStartTime = null;
var currentTimerDebugID = null;
var currentTimerStartTime = null;
var currentTimerType = null;

function clearHistory() {
  ReactComponentTreeDevtool.purgeUnmountedComponents();
  ReactNativeOperationHistoryDevtool.clearHistory();}


function getTreeSnapshot(registeredIDs) {
  return registeredIDs.reduce(function (tree, id) {
    var ownerID = ReactComponentTreeDevtool.getOwnerID(id);
    var parentID = ReactComponentTreeDevtool.getParentID(id);
    tree[id] = { 
      displayName: ReactComponentTreeDevtool.getDisplayName(id), 
      text: ReactComponentTreeDevtool.getText(id), 
      updateCount: ReactComponentTreeDevtool.getUpdateCount(id), 
      childIDs: ReactComponentTreeDevtool.getChildIDs(id), 
      // Text nodes don't have owners but this is close enough.
      ownerID: ownerID || ReactComponentTreeDevtool.getOwnerID(parentID), 
      parentID: parentID };

    return tree;}, 
  {});}


function resetMeasurements() {
  if (process.env.NODE_ENV !== 'production') {
    var previousStartTime = currentFlushStartTime;
    var previousMeasurements = currentFlushMeasurements || [];
    var previousOperations = ReactNativeOperationHistoryDevtool.getHistory();

    if (!isProfiling || currentFlushNesting === 0) {
      currentFlushStartTime = null;
      currentFlushMeasurements = null;
      clearHistory();
      return;}


    if (previousMeasurements.length || previousOperations.length) {
      var registeredIDs = ReactComponentTreeDevtool.getRegisteredIDs();
      flushHistory.push({ 
        duration: performanceNow() - previousStartTime, 
        measurements: previousMeasurements || [], 
        operations: previousOperations || [], 
        treeSnapshot: getTreeSnapshot(registeredIDs) });}



    clearHistory();
    currentFlushStartTime = performanceNow();
    currentFlushMeasurements = [];}}



function checkDebugID(debugID) {
  process.env.NODE_ENV !== 'production' ? warning(debugID, 'ReactDebugTool: debugID may not be empty.') : void 0;}


var ReactDebugTool = { 
  addDevtool: function /* istanbul ignore next */addDevtool(devtool) {
    eventHandlers.push(devtool);}, 

  removeDevtool: function /* istanbul ignore next */removeDevtool(devtool) {
    for (var i = 0; i < eventHandlers.length; i++) {
      if (eventHandlers[i] === devtool) {
        eventHandlers.splice(i, 1);
        i--;}}}, 



  beginProfiling: function /* istanbul ignore next */beginProfiling() {
    if (process.env.NODE_ENV !== 'production') {
      if (isProfiling) {
        return;}


      isProfiling = true;
      flushHistory.length = 0;
      resetMeasurements();}}, 


  endProfiling: function /* istanbul ignore next */endProfiling() {
    if (process.env.NODE_ENV !== 'production') {
      if (!isProfiling) {
        return;}


      isProfiling = false;
      resetMeasurements();}}, 


  getFlushHistory: function /* istanbul ignore next */getFlushHistory() {
    if (process.env.NODE_ENV !== 'production') {
      return flushHistory;}}, 


  onBeginFlush: function /* istanbul ignore next */onBeginFlush() {
    if (process.env.NODE_ENV !== 'production') {
      currentFlushNesting++;
      resetMeasurements();}

    emitEvent('onBeginFlush');}, 

  onEndFlush: function /* istanbul ignore next */onEndFlush() {
    if (process.env.NODE_ENV !== 'production') {
      resetMeasurements();
      currentFlushNesting--;}

    emitEvent('onEndFlush');}, 

  onBeginLifeCycleTimer: function /* istanbul ignore next */onBeginLifeCycleTimer(debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
    if (process.env.NODE_ENV !== 'production') {
      if (isProfiling && currentFlushNesting > 0) {
        process.env.NODE_ENV !== 'production' ? warning(!currentTimerType, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
        currentTimerStartTime = performanceNow();
        currentTimerDebugID = debugID;
        currentTimerType = timerType;}}}, 



  onEndLifeCycleTimer: function /* istanbul ignore next */onEndLifeCycleTimer(debugID, timerType) {
    checkDebugID(debugID);
    if (process.env.NODE_ENV !== 'production') {
      if (isProfiling && currentFlushNesting > 0) {
        process.env.NODE_ENV !== 'production' ? warning(currentTimerType === timerType, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
        currentFlushMeasurements.push({ 
          timerType: timerType, 
          instanceID: debugID, 
          duration: performanceNow() - currentTimerStartTime });

        currentTimerStartTime = null;
        currentTimerDebugID = null;
        currentTimerType = null;}}


    emitEvent('onEndLifeCycleTimer', debugID, timerType);}, 

  onBeginReconcilerTimer: function /* istanbul ignore next */onBeginReconcilerTimer(debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onBeginReconcilerTimer', debugID, timerType);}, 

  onEndReconcilerTimer: function /* istanbul ignore next */onEndReconcilerTimer(debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onEndReconcilerTimer', debugID, timerType);}, 

  onBeginProcessingChildContext: function /* istanbul ignore next */onBeginProcessingChildContext() {
    emitEvent('onBeginProcessingChildContext');}, 

  onEndProcessingChildContext: function /* istanbul ignore next */onEndProcessingChildContext() {
    emitEvent('onEndProcessingChildContext');}, 

  onNativeOperation: function /* istanbul ignore next */onNativeOperation(debugID, type, payload) {
    checkDebugID(debugID);
    emitEvent('onNativeOperation', debugID, type, payload);}, 

  onSetState: function /* istanbul ignore next */onSetState() {
    emitEvent('onSetState');}, 

  onSetDisplayName: function /* istanbul ignore next */onSetDisplayName(debugID, displayName) {
    checkDebugID(debugID);
    emitEvent('onSetDisplayName', debugID, displayName);}, 

  onSetChildren: function /* istanbul ignore next */onSetChildren(debugID, childDebugIDs) {
    checkDebugID(debugID);
    emitEvent('onSetChildren', debugID, childDebugIDs);}, 

  onSetOwner: function /* istanbul ignore next */onSetOwner(debugID, ownerDebugID) {
    checkDebugID(debugID);
    emitEvent('onSetOwner', debugID, ownerDebugID);}, 

  onSetText: function /* istanbul ignore next */onSetText(debugID, text) {
    checkDebugID(debugID);
    emitEvent('onSetText', debugID, text);}, 

  onMountRootComponent: function /* istanbul ignore next */onMountRootComponent(debugID) {
    checkDebugID(debugID);
    emitEvent('onMountRootComponent', debugID);}, 

  onMountComponent: function /* istanbul ignore next */onMountComponent(debugID) {
    checkDebugID(debugID);
    emitEvent('onMountComponent', debugID);}, 

  onUpdateComponent: function /* istanbul ignore next */onUpdateComponent(debugID) {
    checkDebugID(debugID);
    emitEvent('onUpdateComponent', debugID);}, 

  onUnmountComponent: function /* istanbul ignore next */onUnmountComponent(debugID) {
    checkDebugID(debugID);
    emitEvent('onUnmountComponent', debugID);} };



if (process.env.NODE_ENV !== 'production') {
  var ReactInvalidSetStateWarningDevTool = require('./ReactInvalidSetStateWarningDevTool');
  var ReactNativeOperationHistoryDevtool = require('./ReactNativeOperationHistoryDevtool');
  var ReactComponentTreeDevtool = require('./ReactComponentTreeDevtool');
  ReactDebugTool.addDevtool(ReactInvalidSetStateWarningDevTool);
  ReactDebugTool.addDevtool(ReactComponentTreeDevtool);
  ReactDebugTool.addDevtool(ReactNativeOperationHistoryDevtool);
  var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
  if (/[?&]react_perf\b/.test(url)) {
    ReactDebugTool.beginProfiling();}}



module.exports = ReactDebugTool;